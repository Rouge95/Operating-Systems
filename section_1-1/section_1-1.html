<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Basic HTML Page</title>
</head>

<body>
    <div id="header"></div>

    <main>
        <nav class="breadcrumb">
            <a href="../index.html">Index</a> &gt;
            <span>Section 1.1</span>
        </nav>

        <div class="content">
            <h1>Computer Hardware: Organization, Architecture, and Operating Systems</h1>
            <hr>
        </div>

        <div id="content">
            <details>
                <summary><h2>Key Concepts</h2></summary>
                <h3>Blade Server</h3>
                <p>A blade server is a modular server board inserted into a shared chassis providing CPU, memory, and
                    minimal I/O.</p>
                
                <h3>Central Processing Unit (CPU)</h3>
                <p>The CPU executes program instructions via fetch, decode, and execute stages using advanced techniques for
                    efficiency.</p>
                
                <h3>Clustered System</h3>
                <p>A clustered system is multiple computers (nodes) working together as a single logical system for high
                    availability.</p>
                
                <h3>Device Driver</h3>
                <p>A device driver allows the OS to communicate with hardware by translating generic requests into
                    device-specific commands.</p>
                
                <h3>Direct Memory Access (DMA)</h3>
                <p>DMA allows devices to transfer data directly to/from memory without continuous CPU involvement.</p>
                
                <h3>Firmware and ROM (or EEPROM)</h3>
                <p>Firmware is low-level software in non-volatile memory that initializes and controls hardware.</p>
                
                <h3>Input/Output (I/O) Devices</h3>
                <p>I/O devices enable interaction between a computer and its environment, supplying input and output data.
                </p>
                
                <h3>Instruction–Execution Cycle</h3>
                <p>The instruction-execution cycle is the CPU loop of fetching, decoding, executing, and writing back
                    instructions.</p>
                
                <h3>Instruction Register</h3>
                <p>The instruction register holds the currently executing instruction for decoding and execution control.
                </p>
                
                <h3>Memory and RAM (and DRAM)</h3>
                <p>Memory stores data for immediate use, RAM is volatile high-speed memory, and DRAM stores bits that must
                    be refreshed.</p>
                
                <h3>Multiple Computing Cores</h3>
                <p>Multi-core processors integrate several cores in one CPU to execute instructions concurrently.</p>
                
                <h3>Multiprocessor System (Parallel Systems)</h3>
                <p>Multiprocessor systems use multiple CPUs in parallel to improve performance and reliability.</p>
                
                <h3>Non-Uniform Memory Access (NUMA)</h3>
                <p>NUMA is memory architecture where access speed depends on memory location relative to the processor.</p>
                
                <h3>Small Computer System Interface (SCSI)</h3>
                <p>SCSI is a standard for connecting and transferring data between computers and peripheral devices.</p>
                
                <h3>Storage-Area Network (SAN)</h3>
                <p>SAN is a high-speed network providing block-level access to centralized storage.</p>
                
                <h3>Storage Device Hierarchy</h3>
                <p>The storage hierarchy organizes storage by speed, cost, and capacity for performance optimization.</p>
                
                <h3>Symmetric Multiprocessing (SMP)</h3>
                <p>SMP is a multiprocessor architecture where all CPUs share memory equally.</p>
                
                <h3>Uniform Memory Access (UMA)</h3>
                <p>UMA is a memory model where all processors access memory with uniform latency.</p>
                
                <h3>BSD UNIX</h3>
                <p>BSD UNIX is the Berkeley Software Distribution branch of UNIX emphasizing portability, stability, and
                    networking.</p>
                
                <h3>Cache Management</h3>
                <p>Cache management controls high-speed memory layers to reduce latency and maintain consistency.</p>
                
                <h3>Caching</h3>
                <p>Caching stores copies of data in faster memory to speed up future access.</p>
                
                <h3>Client–Server</h3>
                <p>Client-server is a model where clients request services and servers provide them over standardized
                    protocols.</p>
                
                <h3>Data-Fetch Cycle</h3>
                <p>The data-fetch cycle is how a CPU retrieves operands from memory during instruction execution.</p>
                
                <h3>Dual-Mode Operation</h3>
                <p>Dual-mode operation distinguishes between user mode and kernel mode for protection and privilege control.
                </p>
                
                <h3>File</h3>
                <p>A file is a persistent logical collection of data stored on secondary storage.</p>
                
                <h3>Handheld System</h3>
                <p>A handheld system is a portable computing device optimized for mobility and energy efficiency.</p>
                
                <h3>Instruction-Fetch Cycle</h3>
                <p>The instruction-fetch cycle retrieves the next instruction for execution from memory.</p>
                
                <h3>Interactive (Hands-On) Computer System</h3>
                <p>Interactive systems allow continuous user input with immediate feedback.</p>
                
                <h3>Interrupt-Driven I/O Cycle</h3>
                <p>Interrupt-driven I/O lets devices signal the CPU when an operation completes to improve efficiency.</p>
                
                <h3>I/O Subsystem</h3>
                <p>The I/O subsystem manages communication between the computer and external devices.</p>
                
                <h3>Job Pool and Job Scheduling</h3>
                <p>A job pool is a set of processes awaiting execution, with scheduling determining their CPU allocation.
                </p>
                
                <h3>Kernel Mode</h3>
                <p>Kernel mode is the CPU's privileged state allowing full access to hardware and system resources.</p>
                
                <h3>Linux</h3>
                <p>Linux is an open-source, UNIX-like OS kernel supporting multitasking, multiuser operation, and
                    modularity.</p>
                
                <h3>Mass Storage</h3>
                <p>Mass storage is non-volatile long-term storage for files, databases, and OS components.</p>
                
                <h3>Memory Management</h3>
                <p>Memory management controls allocation, use, and protection of main memory for processes.</p>
                
                <h3>Multimedia System</h3>
                <p>Multimedia systems process and present multiple media types with strict timing constraints.</p>
                
                <h3>Multiprogramming</h3>
                <p>Multiprogramming allows multiple programs in memory to share the CPU to maximize utilization.</p>
                
                <h3>Network Operating System</h3>
                <p>A network OS enables multiple computers to communicate, share resources, and coordinate over a network.
                </p>
                
                <h3>Open-Source Operating System</h3>
                <p>Open-source OS provides publicly available source code for study, modification, and redistribution.</p>
                
                <h3>Peer-to-Peer</h3>
                <p>P2P networks allow nodes to act as both clients and servers without centralized control.</p>
                
                <h3>Privileged Instructions</h3>
                <p>Privileged instructions are CPU operations restricted to kernel mode to maintain security and stability.
                </p>
                
                <h3>Process</h3>
                <p>A process is an executing instance of a program with its own code, data, and execution context.</p>
                
                <h3>Process Management</h3>
                <p>Process management handles creation, scheduling, synchronization, and termination of processes.</p>
                
                <h3>Program Counter</h3>
                <p>The program counter holds the address of the next instruction to define control flow.</p>
                
                <h3>Protection</h3>
                <p>Protection mechanisms control access to system resources to prevent unauthorized interference.</p>
                
                <h3>Real-Time Operating Systems</h3>
                <p>RTOS guarantee deterministic responses to external events within strict time constraints.</p>
                
                <h3>Response Time</h3>
                <p>Response time is the interval between a request and the system’s first observable output.</p>
                
                <h3>Security</h3>
                <p>Security protects systems and data from unauthorized actions and ensures integrity and availability.</p>
                
                <h3>Solaris</h3>
                <p>Solaris is an enterprise UNIX OS designed for high-performance, scalable, and reliable computing.</p>
                
                <h3>Swapping</h3>
                <p>Swapping temporarily moves processes between memory and disk to manage memory resources.</p>
                
                <h3>Time-sharing / Multitasking</h3>
                <p>Time-sharing enables multiple processes to share a CPU, creating the illusion of simultaneous execution.
                </p>
                
                <h3>Timer</h3>
                <p>A timer generates interrupts to control CPU execution time and implement preemption.</p>
                
                <h3>Trap / Exception</h3>
                <p>A trap/exception transfers control from user code to the OS for error handling or system calls.</p>
                
                <h3>User Mode</h3>
                <p>User mode is a restricted CPU execution state preventing access to critical instructions and hardware.
                </p>
                
                <h3>Virtual Memory</h3>
                <p>Virtual memory abstracts physical memory to provide processes with a large, contiguous address space.</p>
            </details>
            <details>
                <summary><h2>Study</h2></summary>
                
            
                <h3>1. Why Operating Systems Are Important</h3>
                
                <p><strong>Core idea:</strong> An operating system (OS) is the manager of the computer’s resources.</p>
                
                <ul>
                    <li><strong>Resource management:</strong> Controls CPU, memory, storage, and I/O devices.</li>
                    <li><strong>Process management:</strong> Loads, schedules, and terminates programs.</li>
                    <li><strong>Memory management:</strong> Allocates RAM and isolates processes.</li>
                    <li><strong>File systems:</strong> Organizes persistent storage.</li>
                    <li><strong>Abstraction:</strong> Hides hardware complexity behind simple interfaces (system calls).</li>
                </ul>
                
                <p><strong>Why this matters:</strong> Without an OS, every program would need to control hardware directly. That is
                    inefficient, unsafe, and difficult to scale.</p>
                
                <h3>Running a Program Without an Operating System</h3>
                
                <p>This is common in embedded systems such as microcontrollers.</p>
                
                <ul>
                    <li>The program is written in low-level language (C/assembly).</li>
                    <li>It is compiled into machine code.</li>
                    <li>The binary is flashed directly into ROM/flash memory.</li>
                    <li>On power-up, the CPU begins execution from a fixed reset vector address.</li>
                </ul>
                
                <p>There is no scheduler or file system. The program itself handles hardware initialization, timing, and I/O directly.
                    This is often called a <strong>bare-metal system</strong>.</p>
                
                <p><strong>Key takeaway:</strong> An OS provides structure and abstraction. Without it, the program must handle
                    everything.</p>
                
                <hr>
                
                <h3>2. Instruction Execution in a von Neumann Architecture</h3>
                
                <p><strong>Core principle:</strong> Instructions and data share the same memory space.</p>
                
                <p>The execution cycle follows the <strong>fetch–decode–execute</strong> model:</p>
                
                <ol>
                    <li><strong>Fetch:</strong> The CPU uses the Program Counter (PC) to retrieve the next instruction from memory.</li>
                    <li><strong>Decode:</strong> The Control Unit interprets the instruction (operation type, operands).</li>
                    <li><strong>Execute:</strong> The Arithmetic Logic Unit (ALU) or other unit performs the operation.</li>
                    <li><strong>Write-back:</strong> Results are stored in registers or memory.</li>
                    <li><strong>PC Update:</strong> The PC increments or jumps to a new address.</li>
                </ol>
                
                <p><strong>Important concept:</strong> Because instructions and data share memory, this design can suffer from the “von
                    Neumann bottleneck” — limited bandwidth between CPU and memory.</p>
                
                <p><strong>Key takeaway:</strong> Every program runs as repeated fetch–decode–execute cycles.</p>
                
                <hr>
                
                <h3>3. Interrupt-Driven I/O</h3>
                
                <p><strong>Core idea:</strong> The CPU does not constantly poll devices. Instead, devices notify the CPU when they need
                    attention.</p>
                
                <h3>Step-by-Step Flow</h3>
                
                <ol>
                    <li><strong>Device Controller:</strong> Hardware component attached to a device (e.g., disk, keyboard).</li>
                    <li><strong>Device Driver:</strong> OS software that communicates with the controller.</li>
                    <li><strong>I/O Request:</strong> A process makes a system call (e.g., read).</li>
                    <li><strong>Driver Programs Controller:</strong> The driver writes commands into controller registers.</li>
                    <li><strong>Device Operates:</strong> The controller performs the I/O operation independently.</li>
                    <li><strong>Interrupt:</strong> When finished, the controller raises an interrupt signal.</li>
                    <li><strong>Interrupt Handler:</strong> The CPU pauses the current process and executes an Interrupt Service Routine
                        (ISR).</li>
                    <li><strong>Completion:</strong> The OS updates process state and resumes execution.</li>
                </ol>
                
                <p><strong>Why this is efficient:</strong> The CPU can perform other work instead of waiting for slow I/O operations.
                </p>
                
                <p><strong>Key takeaway:</strong> Interrupt-driven I/O improves performance by allowing asynchronous device
                    communication.</p>
                
                <hr>
                
                <h3>Final Summary — What You Should Remember</h3>
                
                <ul>
                    <li>An OS manages hardware and provides abstraction.</li>
                    <li>Bare-metal systems execute code directly from memory without OS services.</li>
                    <li>Instruction execution follows the fetch–decode–execute cycle in von Neumann systems.</li>
                    <li>Interrupt-driven I/O allows devices to signal completion instead of being constantly polled.</li>
                </ul>

            </details>

            <hr>
            <h2>Activities</h2>
            <video controls>
                <source src="interrupt_io_demo.mp4" type="video/mp4">
                
            </video>
            <p>Interrupt-driven I/O <br><i> note: keyboards (and some other devices) are slightly different because they are event-driven, not process-driven.</i></p>
            <hr>


            <video controls>
                <source src="computer_function.mp4" type="video/mp4">
            
            </video>
            <p>Basic Computer Abstraction<br> note: "Device" abstacts Device Controller (Hw) & Driver (OS) .</p>
            <hr>
            <iframe src="https://www.youtube.com/embed/v97HAhwQMj8"
                title="The Fetch Decode Execute Cycle | GCSE Computer Science | BBC Bitesize | Too Tall Productions"
                style="width:100%; max-width:1451px; height:564px;border-radius:10px;" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                referrerpolicy="strict-origin-when-cross-origin" allowfullscreen>
            </iframe>
            <p>CPU Functionality</p>
            <hr>

        </div>
    </main>

    <div id="footer"></div>

    <script>
        fetch('../header.html').then(r => r.text()).then(data => document.getElementById('header').innerHTML = data);
        fetch('../footer.html').then(r => r.text()).then(data => document.getElementById('footer').innerHTML = data);
    </script>
</body>

</html>